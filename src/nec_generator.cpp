#include "nec_generator.h"
#include <iostream>
#include <iomanip>
#include <sstream>
#include <cmath>

namespace stl_to_eznec {

NECGenerator::NECGenerator() 
    : includeComments_(true), includePattern_(true), includeCurrent_(false) {
}

std::string NECGenerator::generateNEC(
    const std::vector<Triangle>& triangles,
    const MaterialProperties& material,
    const FrequencyCalculator& frequency,
    const AntennaWire& antenna,
    const std::string& modelName,
    bool hasAntenna,
    double waterlineHeight,
    const WaterProperties* water) {
    
    necContent_.clear();
    
    // Generate header
    necContent_ += generateHeader(modelName, frequency);
    
    // Generate geometry
    necContent_ += generateGeometry(triangles, material, antenna, hasAntenna);
    
    // Generate excitation (if antenna exists)
    if (hasAntenna && antenna.isDetected) {
        necContent_ += generateExcitation(antenna);
    }
    
    // Generate ground
    necContent_ += generateGround(waterlineHeight, water);
    
    // Generate frequency
    necContent_ += generateFrequency(frequency);
    
    // Generate pattern
    if (includePattern_) {
        necContent_ += generatePattern();
    }
    
    // Generate current
    if (includeCurrent_) {
        necContent_ += generateCurrent();
    }
    
    necContent_ += "EN\n";
    
    return necContent_;
}

std::string NECGenerator::generateNECStructureOnly(
    const std::vector<Triangle>& triangles,
    const MaterialProperties& material,
    const std::string& modelName) {
    
    necContent_.clear();
    
    // Generate header
    std::stringstream header;
    header << "CM ================================================================\n";
    header << "CM " << modelName << " - Structure Only\n";
    header << "CM Generated by STL-to-EZ/NEC Converter\n";
    header << "CM Date: " << __DATE__ << " " << __TIME__ << "\n";
    header << "CM ================================================================\n";
    header << "CM\n";
    header << "CM Material: " << material.name << "\n";
    header << "CM Conductivity: " << std::scientific << std::setprecision(2) << material.conductivity << " S/m\n";
    header << "CM Relative Permittivity: " << std::fixed << std::setprecision(1) << material.relativePermittivity << "\n";
    header << "CM ================================================================\n";
    header << "CE\n\n";
    
    necContent_ += header.str();
    
    // Generate geometry
    necContent_ += generateGeometry(triangles, material, AntennaWire(), false);
    
    necContent_ += "EN\n";
    
    return necContent_;
}

std::string NECGenerator::generateHeader(const std::string& modelName, const FrequencyCalculator& frequency) {
    std::stringstream header;
    
    if (includeComments_) {
        header << "CM ================================================================\n";
        header << "CM " << modelName << "\n";
        header << "CM Generated by STL-to-EZ/NEC Converter\n";
        header << "CM Date: " << __DATE__ << " " << __TIME__ << "\n";
        header << "CM ================================================================\n";
        header << "CM\n";
        
        if (frequency.isValidFrequency()) {
            header << "CM Frequency: " << std::fixed << std::setprecision(1) << frequency.getFrequencyMHz() << " MHz\n";
            header << "CM Wavelength: " << std::fixed << std::setprecision(3) << frequency.getWavelength() << " m\n";
            header << "CM Band: " << frequency.getFrequencyBand() << "\n";
            header << "CM Grid Spacing: " << std::fixed << std::setprecision(1) << frequency.getRecommendedGridSpacingCm() << " cm\n";
        }
        
        header << "CM ================================================================\n";
        header << "CE\n\n";
    }
    
    return header.str();
}

std::string NECGenerator::generateGeometry(
    const std::vector<Triangle>& triangles,
    const MaterialProperties& material,
    const AntennaWire& antenna,
    bool hasAntenna) {
    
    std::stringstream geometry;
    
    geometry << "GE 0\n";
    
    int wireTag = 1;
    
    // Generate antenna wire first (if exists)
    if (hasAntenna && antenna.isDetected) {
        geometry << generateAntennaWire(antenna, wireTag);
    }
    
    // Generate structure wires
    geometry << generateStructureWires(triangles, material, wireTag);
    
    geometry << "GE 1\n\n";
    
    return geometry.str();
}

std::string NECGenerator::generateAntennaWire(const AntennaWire& antenna, int& wireTag) {
    std::stringstream wire;
    
    if (!antenna.isDetected || antenna.path.size() < 2) {
        return wire.str();
    }
    
    // Calculate segments based on length
    int segments = static_cast<int>(std::ceil(antenna.length / 0.05)); // 5cm grid spacing
    if (segments % 2 == 0) segments++; // Ensure odd number for center feed
    
    // Generate wire segments
    for (size_t i = 1; i < antenna.path.size(); ++i) {
        const Point3D& start = antenna.path[i-1];
        const Point3D& end = antenna.path[i];
        
        wire << "GW " << wireTag << " " << segments << " ";
        wire << formatCoordinate(start.x) << " " << formatCoordinate(start.y) << " " << formatCoordinate(start.z) << " ";
        wire << formatCoordinate(end.x) << " " << formatCoordinate(end.y) << " " << formatCoordinate(end.z) << " ";
        wire << formatCoordinate(antenna.radius) << "\n";
        
        wireTag++;
    }
    
    return wire.str();
}

std::string NECGenerator::generateStructureWires(
    const std::vector<Triangle>& triangles,
    const MaterialProperties& material,
    int& wireTag) {
    
    std::stringstream wires;
    
    // Add material properties comment
    wires << getMaterialComment(material) << "\n";
    
    // For now, generate simple wire representation of triangles
    // In a more sophisticated implementation, we would properly triangulate the structure
    
    for (const auto& triangle : triangles) {
        // Generate three edges of the triangle as wires
        for (int i = 0; i < 3; ++i) {
            const Point3D& start = triangle.vertices[i];
            const Point3D& end = triangle.vertices[(i + 1) % 3];
            
            double length = start.distance(end);
            int segments = static_cast<int>(std::ceil(length / 0.1)); // 10cm grid spacing for structure
            
            wires << "GW " << wireTag << " " << segments << " ";
            wires << formatCoordinate(start.x) << " " << formatCoordinate(start.y) << " " << formatCoordinate(start.z) << " ";
            wires << formatCoordinate(end.x) << " " << formatCoordinate(end.y) << " " << formatCoordinate(end.z) << " ";
            wires << formatCoordinate(0.002) << "\n"; // 2mm radius for structure wires
            
            wireTag++;
        }
    }
    
    return wires.str();
}

std::string NECGenerator::generateExcitation(const AntennaWire& antenna) {
    std::stringstream excitation;
    
    if (!antenna.isDetected) return excitation.str();
    
    // Find center segment of antenna
    int centerSegment = static_cast<int>(std::ceil(antenna.path.size() / 2.0));
    
    excitation << "EX 0 1 " << centerSegment << " 0 1.0 0.0\n\n";
    
    return excitation.str();
}

std::string NECGenerator::generateGround(double waterlineHeight, const WaterProperties* water) {
    std::stringstream ground;
    
    if (waterlineHeight > 0 && water != nullptr) {
        // Marine ground with water properties
        ground << "GN 2 0 0 0 " << std::fixed << std::setprecision(1) << water->relativePermittivity;
        ground << " " << formatScientific(water->conductivity) << "\n\n";
    } else {
        // Perfect ground
        ground << "GN -1\n\n";
    }
    
    return ground.str();
}

std::string NECGenerator::generateFrequency(const FrequencyCalculator& frequency) {
    std::stringstream freq;
    
    if (frequency.isValidFrequency()) {
        freq << "FR 0 1 0 0 " << std::fixed << std::setprecision(1) << frequency.getFrequencyMHz() << "\n\n";
    }
    
    return freq.str();
}

std::string NECGenerator::generatePattern() {
    std::stringstream pattern;
    
    pattern << "RP 0 37 73 1000 0.0 0.0 5.0 5.0\n\n";
    
    return pattern.str();
}

std::string NECGenerator::generateCurrent() {
    std::stringstream current;
    
    current << "NH 0 0 0 0 0 0 0 0 0\n\n";
    
    return current.str();
}

std::string NECGenerator::formatCoordinate(double value) {
    std::stringstream ss;
    ss << std::fixed << std::setprecision(6) << value;
    return ss.str();
}

std::string NECGenerator::formatScientific(double value) {
    std::stringstream ss;
    ss << std::scientific << std::setprecision(2) << value;
    return ss.str();
}

std::string NECGenerator::getMaterialComment(const MaterialProperties& material) {
    std::stringstream comment;
    comment << "CM Material: " << material.name;
    comment << " (σ = " << std::scientific << std::setprecision(1) << material.conductivity;
    comment << " S/m, εᵣ = " << std::fixed << std::setprecision(1) << material.relativePermittivity << ")";
    return comment.str();
}

} // namespace stl_to_eznec
